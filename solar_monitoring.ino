/*#define BLYNK_TEMPLATE_ID "TMPL-nOKtFen"
#define BLYNK_DEVICE_NAME "Solar Energy Meter"
#define BLYNK_AUTH_TOKEN "ZY9VzzvD6O5Ta5zvUryHL6y6e-JqUAma"
#define BLYNK_PRINT Serial*/


#include <Adafruit_GFX.h> //Graphics for OLED Display
#include <Adafruit_SSD1306.h> //Display data on OLED
#include <DallasTemperature.h> //Library for DS18B20
#include <OneWire.h> //Library for DS18B20
#include "Wire.h" //Library for ESP32 to communicate with I2C device (OLED)
#include <WiFi.h> //Library to allow microcontroller to connect to the internet         
#include <BlynkSimpleEsp32.h> //Allow ESP32 to be used with Blynk IOT

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define INPUT_VOLTAGE_SENSE_PIN 34 //Pin for voltage sensor
#define INPUT_CURRENT_SENSE_PIN 35 //Pin for current sensor
#define TEMP_SENSE_PIN 4
#define VOLTAGE_SCALE  7.911 // R1+R2 / R2 // ( 47K + 6.8K ) / 6.8K
#define CURRENT_SCALE  1.5 // R4+R5 / R5 // ( 1K + 2K ) / 2K
    
double sensi = 100; //Sensitivity of the sensor 
double ACSoffset = 500; // 
unsigned long last_time = 0;
unsigned long current_time = 0;
float power =0 ; // Power in Watts
float energy =0 ; // Energy in Watt-Hour
float tempC=0; // Temp in Celsius
/*float tempF = 0; Temp in F*/
float saving=0; // cost savings 
   
    
WiFiClient client;
// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
// GPIO where the DS18B20 is connected to
const int oneWireBus = 2;    
// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(TEMP_SENSE_PIN);
DallasTemperature sensors(&oneWire);
    
//char auth[] = BLYNK_AUTH_TOKEN;     
//char ssid[] = "Pong_2.4G"; // WiFi Router ssid
//char pass[] = "25421966"; // WiFi Router password
   
    
void setup() {
  Serial.begin(115200);
  //Blynk.begin(auth, ssid, pass);
  sensors.begin();
  
  
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { 
    Serial.println(F("SSD1306 allocation failed"));
    for (;;); //use to test OLED display. Loop forver
  }  
  display.clearDisplay();  
  display.setTextColor(WHITE);
  display.display();  
  delay(500);
}

    

void loop()
{
 
  // read voltage and current
  float voltage = abs( return_voltage_value(INPUT_VOLTAGE_SENSE_PIN)) ;
  float current = abs( return_current_value(INPUT_CURRENT_SENSE_PIN)) ;

 // read temperature from DS18B20
  sensors.requestTemperatures(); // get temperature
  tempC = sensors.getTempCByIndex(0); //Get temperature in Celsius
  /*tempF = sensors.getTempFByIndex(0); //Get temperature in Fahrenheit*/

  // Calculate power and energy
  power = current * voltage ; // calculate power in Watt
  last_time = current_time;
  current_time = millis();    
  energy = energy +  power *(( current_time - last_time) /3600000.0) ; // calculate power in Watt-Hour // 1 Hour = 60mins x 60 Secs x 1000 Milli Secs

  saving = 6.5 * ( energy /1000 ); // 6.5 is cost per kWh 
  

  // Display Data on Serial Monitor  
  
  Serial.print("Voltage: ");
  Serial.println(voltage);
  Serial.print("Current: ");
  Serial.println(current);
  Serial.print("Power: ");
  Serial.println(power);
  Serial.print("Energy: ");
  Serial.println(energy);
  Serial.print("Temp: ");
  Serial.println(tempC);
  delay(1000);

//  Display Data on OLED Display 
  // Display Solar Panel Voltage 
  display.setTextSize(1);
  display.clearDisplay();
  display.setCursor(10, 10);
  display.print(voltage,1);
  display.print(" V");

  // Display Solar Panel Current 
  
  display.setCursor(70, 10);

  if (current >0 && current < 1 )
  {
   display.print(current*1000,0);
   display.print(" mA");
  }
  else
  {
  display.print(current,2);  
  display.print(" A");
  }

 // Display Solar Panel Power in Watt

  display.setTextSize(2);
  display.setCursor(10,25);
  display.print(power);
  display.print(" W");

 // Display Energy Generated by the Solar Panel 
  display.setCursor(10,45);
  
  if ( energy >= 1000 )
  {
   display.print(energy/1000,3);
   display.print(" kWh");
  }
  else
  {
  display.print(energy,1);  
  display.print(" Wh");
  }
  display.display();
  display.clearDisplay();
  
  
// Display Data on Blynk App
   /*Blynk.run();  
   Blynk.virtualWrite(2, voltage ); // virtual pin 2
   Blynk.virtualWrite(3, current ); // virtual pin 3 
   Blynk.virtualWrite(0, power);    // virtual pin 0
   Blynk.virtualWrite(4,energy/1000);// virtual pin 4
   Blynk.virtualWrite(5,tempC );    // virtual pin 5  
   Blynk.virtualWrite(1,saving);    // virtual pin 1  
   delay(1000);*/ 
}
 
// Function to Calculate Solar Panel Voltage 
 
double return_voltage_value(int pin_no)
{
  double tmp = 0;
  double ADCVoltage = 0;
  double inputVoltage = 0;
  double avg = 0;
  for (int i = 0; i < 100; i++)
  {
    tmp = tmp + analogRead(pin_no);
  }
  avg = tmp / 100;
  ADCVoltage = ((avg * 3.3) / (4095)) + 0.184 ; // 0.184 is offset adjusted by heat and try
  inputVoltage = ADCVoltage * VOLTAGE_SCALE; 
  return inputVoltage;
}


// Function to Calculate Solar Panel Current 

double return_current_value(int pin_no)
{
  double tmp = 0;
  double avg = 0;
  double ADCVoltage = 0;
  double Amps = 0;
  for (int z = 0; z < 150; z++)
  {
    tmp = tmp + analogRead(pin_no);
  }
  avg = tmp / 150;
  ADCVoltage = ((avg*3331) / 4095); // convert to milli volt
  Amps = (((ADCVoltage * CURRENT_SCALE - ACSoffset-1.5))/sensi)*0.01; // 1.5 is the scaling for voltage divider
  Serial.println(Amps);
  return Amps;
}
